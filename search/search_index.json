{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Software Notes # Welcome to Software Engineering notes of Universidad de M\u00e1laga. What is this about? # My notes of the degree in software engineering at Universidad de M\u00e1laga. Why public? # I would like these notes to be useful to others.","title":"Software Notes"},{"location":"#software-notes","text":"Welcome to Software Engineering notes of Universidad de M\u00e1laga.","title":"Software Notes"},{"location":"#what-is-this-about","text":"My notes of the degree in software engineering at Universidad de M\u00e1laga.","title":"What is this about?"},{"location":"#why-public","text":"I would like these notes to be useful to others.","title":"Why public?"},{"location":"formal_methods/1_introducction/","text":"Introduction # Glossary # Definitions # Formal methods : Logical and mathematical reasoning about the software. Equivalence class : Subset of the input domain which causes the software to behave in the same way for all of them \u2014i.e. correct passwords is an equivalence class, all of them resulting in a correct login. Acronyms # RT : Real Time. I/O : Input/Output. Synonyms # Bug (informal but short) / Software failure (formal but long). GUI : Graphical user interface. Formal methods - The good part # Goals # Reliability Security & Safety Robustness Verification Efficiency Usage # Definition of unambiguous requirements. (ease communication) Better systems understanding and testing . Lower development and maintenance cost . Model benefits : Compile model to implementation, equivalence of models, etc. Software problems it solves # There are some software problems that formal methods solve: When software reaches an inconsistent state (probably a bug ), rebooting is usually the easiest solution. But many systems cannot be rebooted. So it is important to ensure that the system will not reach inconsistent states. Many systems are critical and RT . An error in one of these systems implies very high risk\u2014i.e. physical damage to people, fatalities, environmental damage, legal consequences, high monetary costs, etc. So it is essential to verify that there are no software faults. Most software works with infinite data domains , and it is even difficult to find all equivalence classes (use cases). Experimental test ( I/O ) usually focuses on covering all equivalence classes with at least one test for each equivalence class . Most of the software bugs comes from unexpected input, belonging to an untested equivalence class\u2014probably because it had not been contemplated. So it is crucial to find all equivalence classes . Formal methods can find all of them. It is desirable to prove properties for the equivalence classes. But typically they are either \u201cproved\u201d inductively\u2014by testing with at least one value of the equivalence class and assuming true for the rest of the equivalence class\u2014or proved manually (non-automatically) for each desired property. So it would be useful to prove all \u2014even properties that had not been thought of (maybe undesirable)\u2014posible properties of the system automatically. Formal methods can do it. Formal methods - The bad part # If it is so useful, why is it not used so much? Verification limitations # The requirements or specification may be incorrect . Assuming the specification is correct. Only can be proves that the mathematical abstraction of the model is correct, not its implementation . The most can be said, only in the best case \u2014if the requirements, system specification, compiler and hardware design are correct\u2014, then the program will run correctly . Few resources # Formal methods is relatively recent , so it presents some problems typical of the new disciplines: Few tools . Most of them specialized in very specific fields, having to learn and use different technologies for each purpose. ( Maude aims to solve this problem). Few documentation . Lack of user friendly GUIs . Lack of standardization .","title":"Introduction"},{"location":"formal_methods/1_introducction/#introduction","text":"","title":"Introduction"},{"location":"formal_methods/1_introducction/#glossary","text":"","title":"Glossary"},{"location":"formal_methods/1_introducction/#definitions","text":"Formal methods : Logical and mathematical reasoning about the software. Equivalence class : Subset of the input domain which causes the software to behave in the same way for all of them \u2014i.e. correct passwords is an equivalence class, all of them resulting in a correct login.","title":"Definitions"},{"location":"formal_methods/1_introducction/#acronyms","text":"RT : Real Time. I/O : Input/Output.","title":"Acronyms"},{"location":"formal_methods/1_introducction/#synonyms","text":"Bug (informal but short) / Software failure (formal but long). GUI : Graphical user interface.","title":"Synonyms"},{"location":"formal_methods/1_introducction/#formal-methods-the-good-part","text":"","title":"Formal methods - The good part"},{"location":"formal_methods/1_introducction/#goals","text":"Reliability Security & Safety Robustness Verification Efficiency","title":"Goals"},{"location":"formal_methods/1_introducction/#usage","text":"Definition of unambiguous requirements. (ease communication) Better systems understanding and testing . Lower development and maintenance cost . Model benefits : Compile model to implementation, equivalence of models, etc.","title":"Usage"},{"location":"formal_methods/1_introducction/#software-problems-it-solves","text":"There are some software problems that formal methods solve: When software reaches an inconsistent state (probably a bug ), rebooting is usually the easiest solution. But many systems cannot be rebooted. So it is important to ensure that the system will not reach inconsistent states. Many systems are critical and RT . An error in one of these systems implies very high risk\u2014i.e. physical damage to people, fatalities, environmental damage, legal consequences, high monetary costs, etc. So it is essential to verify that there are no software faults. Most software works with infinite data domains , and it is even difficult to find all equivalence classes (use cases). Experimental test ( I/O ) usually focuses on covering all equivalence classes with at least one test for each equivalence class . Most of the software bugs comes from unexpected input, belonging to an untested equivalence class\u2014probably because it had not been contemplated. So it is crucial to find all equivalence classes . Formal methods can find all of them. It is desirable to prove properties for the equivalence classes. But typically they are either \u201cproved\u201d inductively\u2014by testing with at least one value of the equivalence class and assuming true for the rest of the equivalence class\u2014or proved manually (non-automatically) for each desired property. So it would be useful to prove all \u2014even properties that had not been thought of (maybe undesirable)\u2014posible properties of the system automatically. Formal methods can do it.","title":"Software problems it solves"},{"location":"formal_methods/1_introducction/#formal-methods-the-bad-part","text":"If it is so useful, why is it not used so much?","title":"Formal methods - The bad part"},{"location":"formal_methods/1_introducction/#verification-limitations","text":"The requirements or specification may be incorrect . Assuming the specification is correct. Only can be proves that the mathematical abstraction of the model is correct, not its implementation . The most can be said, only in the best case \u2014if the requirements, system specification, compiler and hardware design are correct\u2014, then the program will run correctly .","title":"Verification limitations"},{"location":"formal_methods/1_introducction/#few-resources","text":"Formal methods is relatively recent , so it presents some problems typical of the new disciplines: Few tools . Most of them specialized in very specific fields, having to learn and use different technologies for each purpose. ( Maude aims to solve this problem). Few documentation . Lack of user friendly GUIs . Lack of standardization .","title":"Few resources"},{"location":"web_engineering/1_introducction/","text":"Introducction # Glossary # Internet : Computers net supported by TCP/IP protocol. PC Era : Before the Web . Acronyms # AI : Artificial Intelligence. CSS : Cascading Style Sheet. DB : Data Base. DL : Deep Learning. DOM : Document Object Model. HTML : HyperText Markup Language. IoT : Internet of Things. OWL : Web Ontology Language. PC : Personal Computer. SPARQL : Semantic Protocol And RDF Query Language. Web : World Wide Web . W3C : World Wide Web Consortium . XHTML : Extensible HyperText Markup Language. XML : Extensible Markup Language. XSLT Extensible Stylesheet Language. Protocols # IP : Internet Protocol. (Internet layer) TCP : Transmission Control Protocol. (Transport layer) HTTP : Hypertext Transfer Protocol. (Application layer) The Web # The Web is one service deployed over Internet . The main file in the Web is the HTML . The Web is supported by HTTP over TCP/IP . The Web is standardised by W3C since 1994. The Web has evolved from PC Era to Web 4.0. Web 1.0 # Started in 1991. People connecting to servers. Static webs. Few content producers / Many readers. Rreduced interaction. Tecnologies: # HTTP as application protocol. HTML as information document. Web 2.0 # Started in 2004. People connecting to people. Blogs and social networks began. Sharing contents. Communities. Tecnologies # XHTML and CSS to data presentation. DOM for interactivity. XML and XSLT for information sharing. JavaScript and Ajax. Web 3.0 # Started in 2010. Semantic web. Software capable of process, reason and logic deduction. Well-labeled information. Tecnologies # OWL-S for ontology. SPARQL for DB queries. Web 4.0 # Started in 2020. Distributed resources. Configurable services. Massively scalable services. Cloud computing, portability, IoT, AI and DL. New interfaces (i.e. voice interfaces). Web applications # This has been the evolution of web applications: Document centric : Static HTML . Interactive : Dynamic HTML generation. Transactional : DB queries and transactions. Workflow-based : To manage workflows across departments, organisations and companies, etc. Collaborative : Shared projects and information. Portal-oriented (Website) : Offers a broad array of resources and services\u2014usually related. Ubiquitous : Services to be accessed anywhere and anytime. Knowledge based : Personalized based on data. Cloud computing : Computing and storage as a service.","title":"Introducction"},{"location":"web_engineering/1_introducction/#introducction","text":"","title":"Introducction"},{"location":"web_engineering/1_introducction/#glossary","text":"Internet : Computers net supported by TCP/IP protocol. PC Era : Before the Web .","title":"Glossary"},{"location":"web_engineering/1_introducction/#acronyms","text":"AI : Artificial Intelligence. CSS : Cascading Style Sheet. DB : Data Base. DL : Deep Learning. DOM : Document Object Model. HTML : HyperText Markup Language. IoT : Internet of Things. OWL : Web Ontology Language. PC : Personal Computer. SPARQL : Semantic Protocol And RDF Query Language. Web : World Wide Web . W3C : World Wide Web Consortium . XHTML : Extensible HyperText Markup Language. XML : Extensible Markup Language. XSLT Extensible Stylesheet Language.","title":"Acronyms"},{"location":"web_engineering/1_introducction/#protocols","text":"IP : Internet Protocol. (Internet layer) TCP : Transmission Control Protocol. (Transport layer) HTTP : Hypertext Transfer Protocol. (Application layer)","title":"Protocols"},{"location":"web_engineering/1_introducction/#the-web","text":"The Web is one service deployed over Internet . The main file in the Web is the HTML . The Web is supported by HTTP over TCP/IP . The Web is standardised by W3C since 1994. The Web has evolved from PC Era to Web 4.0.","title":"The Web"},{"location":"web_engineering/1_introducction/#web-10","text":"Started in 1991. People connecting to servers. Static webs. Few content producers / Many readers. Rreduced interaction.","title":"Web 1.0"},{"location":"web_engineering/1_introducction/#tecnologies","text":"HTTP as application protocol. HTML as information document.","title":"Tecnologies:"},{"location":"web_engineering/1_introducction/#web-20","text":"Started in 2004. People connecting to people. Blogs and social networks began. Sharing contents. Communities.","title":"Web 2.0"},{"location":"web_engineering/1_introducction/#tecnologies_1","text":"XHTML and CSS to data presentation. DOM for interactivity. XML and XSLT for information sharing. JavaScript and Ajax.","title":"Tecnologies"},{"location":"web_engineering/1_introducction/#web-30","text":"Started in 2010. Semantic web. Software capable of process, reason and logic deduction. Well-labeled information.","title":"Web 3.0"},{"location":"web_engineering/1_introducction/#tecnologies_2","text":"OWL-S for ontology. SPARQL for DB queries.","title":"Tecnologies"},{"location":"web_engineering/1_introducction/#web-40","text":"Started in 2020. Distributed resources. Configurable services. Massively scalable services. Cloud computing, portability, IoT, AI and DL. New interfaces (i.e. voice interfaces).","title":"Web 4.0"},{"location":"web_engineering/1_introducction/#web-applications","text":"This has been the evolution of web applications: Document centric : Static HTML . Interactive : Dynamic HTML generation. Transactional : DB queries and transactions. Workflow-based : To manage workflows across departments, organisations and companies, etc. Collaborative : Shared projects and information. Portal-oriented (Website) : Offers a broad array of resources and services\u2014usually related. Ubiquitous : Services to be accessed anywhere and anytime. Knowledge based : Personalized based on data. Cloud computing : Computing and storage as a service.","title":"Web applications"}]}